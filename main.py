import random


class CFG:
    def __init__(self):
        self.terminals = set()
        self.nonterminals = set()
        self.R = dict()
        self.S = ''

    def show(self):
        print( "start: ", self.S )
        print( "nonterminals: ", self.nonterminals )
        print( "terminals: ", self.terminals )
        print( "productions:")
        for x in self.R :
            print( "    ", x, " ---> ", self.R[ x ] )

    def add_terminal(self, s):
        if s not in self.terminals :
            self.terminals.add( s )

    def add_nonterminal(self, s):
        if s not in self.nonterminals :
            self.nonterminals.add( s )
    
    def set_start(self, s):
        self.S = s

    def add_production(self, s):
        
        s = s.strip()
        nt = s[ 0:1 ]
        self.add_nonterminal( nt )

        if nt not in self.R :
            self.R[ nt ] = set()

        s = s[1:]
        s = s.strip( " " )
        s = s.split( "->" )


        for x in s :
            if x != "" :
                x = x.split( "|" )
                for y in x :
                    y = y.strip()
                    if y != "" :
                        self.R[ nt ].add( y )
                        for ch in y:
                            if ch.isupper() :
                                self.add_nonterminal( ch )
                            else :
                                self.add_terminal( ch )

    def parse(self):
        print( "-----Read a CFG-----" )
        
        print( "\nEnter the Start symbol:")
        s = input()
        self.set_start( s )
        
        print( "\nEnter Productions: (eg: S -> aA | bbB, use # for lambda, when done press Enter )")
        s = input()
        while s != "" :
            self.add_production( s )
            s = input()

        print( "--------------------" )
        pass


def derivate( cfg, s, poz ):

    all = set()
    if not s[ poz ].isupper() :
        all.add( s )
    else:
        st = s[ : poz ]
        dr = s[ poz+1 : ]
        for mij in cfg.R[ s[poz] ] :
            
            if( mij == "#" ):       #LAMBDA
                cur = st+dr 
            else:
                cur = st+mij+dr 

            cur = cur.replace( "#", "" ) 

            all.add( cur )
            # print( st+mij+dr )
    return all

def left_derivation( cfg, s ):
    for i in range( len(s) ):
        if s[i].isupper() :
            return derivate( cfg, s, i )

def right_derivation( cfg, s ):
    for i in range( len(s)-1,-1,-1 ):
        if s[i].isupper() :
            return derivate( cfg, s, i )

def generate_random( cfg, s, max_len ):

    if len( s ) > max_len :
        return set()

    option_list = set()

    once = 0
    for i in range( len(s) ):
        if s[ i ].isupper() :
            once = 1
            option_list = option_list.union( derivate(cfg,s,i) )
    
    if not once :               # nu are nonterminale
        s_aux = set()
        s_aux.add(s)
        return s_aux 
    else:
        ans = set()
        for s in option_list :
            ans = ans | generate_random( cfg, s , max_len )
        return ans
    return set()

def show_randoms( cfg ):
    options = generate_random( cfg, cfg.S , 10 )

    for x in range(0,5):
        print( list(options)[ random.randint(0,len(options)-1) ] )
    
def example( a ):
    if 1: 
        a.set_start("S")
        a.add_production( "S -> aSd | A " )
        a.add_production( "A -> bAcc | bcc " )
    else :
        a.set_start("S")
        a.add_production( "S -> aSb | #" )
        a.add_production( "S -> aSb | xSy | #" )

def derivation_gen( cfg, s, max_len, src ):
    global path

    if len( s ) > max_len :
        return 0

    option_list = set()

    once = 0
    for i in range( len(s) ):
        if s[ i ].isupper() :
            once = 1
            option_list = option_list.union( derivate(cfg,s,i) )
    
    if not once :               # nu are nonterminale
        if src == s :
            path = s
            return 1 
    else:
        for x in option_list :
            if derivation_gen( cfg, x , max_len, src ) :
                path = s + " -> " + path
                return 1

    return 0

###########################################################################





path = ""
a = CFG()

# example( a )
a.parse()

print( "\nSome examples of strings generated by the CFG..." )
show_randoms(a)

print( "\nEnter a string to show it's derivations..." )
s = input()
if not derivation_gen( a, a.S, 12, s ) :
    print( "It does not belong to the CFG")
else: 
    print( path )


print( "\nEnter a string to check if it belongs to a language defined by the CFG...")
s = input()
if not derivation_gen( a, a.S, 12, s ) :
    print( "It does not belong to the CFG")
else: 
    print( "It belongs to the CFG" )
